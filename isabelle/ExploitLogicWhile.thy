theory ExploitLogic
  imports Main "HOL-Word.Word"
begin




(*
  TYPES: Variables, Meta-Variables, Operations, Regions in memory, Expressions, Predicates

  An expression of type E is deterministic. It may contain meta-variables, which should be closed
  by an existential quantifier.

  For example, the predicate:

    Exists ID\<^sub>0 (MetaVar ID\<^sub>0 \<le>\<^sub>s 100) (MetaVar ID\<^sub>0 + MetaVar ID\<^sub>0 ==\<^sub>s Num 0)

  can be read as:
 
    \<exists> v\<^sub>0 \<le> 100 \<cdot> v\<^sub>0 + v\<^sub>0 == 0

  An expression of type E' can be non-deterministic. For example, the expression:

    NDExpr ID\<^sub>0 (MetaVar ID\<^sub>0 \<le>\<^sub>s 100)

  can be read as:

    { v\<^sub>0 .  v\<^sub>0 \<le> 100 }

*)
type_synonym V  = string
type_synonym \<mu>V = int

datatype Op = Plus | Mult | Eq | Le | And
datatype R =  Region E nat ("\<lbrakk>_,_\<rbrakk>")
     and E =
    Num "64 word"   \<comment> \<open>Immediate number\<close>
  | Var V           \<comment> \<open>Normal variable\<close>
  | MetaVar \<mu>V      \<comment> \<open>Meta variable\<close>
  | Deref R         \<comment> \<open>Read from region\<close>
  | SP_AL R R E E   \<comment> \<open>Case split for separation and aliasing\<close>
  | App E Op E      \<comment> \<open>Application of the pure operator op to LHS and RHS\<close>

datatype E' = 
    DExpr E     \<comment> \<open>deterministic\<close>
  | NDExpr \<mu>V E \<comment> \<open>non-deterministic\<close>

datatype P = Exists \<mu>V E P | Expr E

(*
  TYPES: Commands

  See the command semantics (particularly of loop and while) at function "step" below. 
*)

datatype C = 
    Assign V E' (infixl "::=" 40)
  | Store R V
  | Seq C C     (infixl ";" 30)
  | Loop E C
  | While E C
  | Choice C C  (infixl "\<parallel>" 31)


(*
  Some notation for symbolic operators
*)
abbreviation plus_s (infixl "+\<^sub>s" 65)
  where "e0 +\<^sub>s e1 \<equiv> App e0 Plus e1"
abbreviation mult_s (infixl "*\<^sub>s" 70)
  where "e0 *\<^sub>s e1 \<equiv> App e0 Mult e1"
abbreviation equal_s (infixl "==\<^sub>s" 49) 
  where "e0 ==\<^sub>s e1 \<equiv> App e0 Eq e1"
abbreviation less_equal_s (infixl "\<le>\<^sub>s" 49)
  where "e0 \<le>\<^sub>s e1 \<equiv> App e0 Le e1"
abbreviation and_s  (infixr "\<and>\<^sub>s" 35)
  where "e0 \<and>\<^sub>s e1 \<equiv> App e0 And e1"
abbreviation not_s :: "E \<Rightarrow> E"  ("\<not>\<^sub>s _" [40] 40)
  where "\<not>\<^sub>s e \<equiv> e ==\<^sub>s Num 0"


(*
  As state, we simply assign words to variable names.
  Moreover, there is some polymorhpic type 'M representing memory.
*)
record 'M state =
  mem  :: 'M
  vars :: "V \<Rightarrow> 64 word"  

locale memory =
  fixes write_region :: "64 word \<times> nat \<Rightarrow> 64 word \<Rightarrow> 'M state \<Rightarrow> 'M state"
    and read_region  :: "64 word \<times> nat \<Rightarrow> 'M state \<Rightarrow> 64 word"
    and separate     :: "64 word \<times> nat \<Rightarrow> 64 word \<times> nat \<Rightarrow> bool" (infixl "\<bowtie>" 55)
    and aliasing     :: "64 word \<times> nat \<Rightarrow> 64 word \<times> nat \<Rightarrow> bool" (infixl "\<simeq>" 55)
  assumes read_write_SP:                 "r' \<bowtie> r \<Longrightarrow> read_region r (write_region r' v \<sigma>) = read_region r \<sigma>"
      and read_write_AL:                 "read_region r (write_region r v \<sigma>) = v"
      and regs_after_write_region[simp]: "vars (write_region r v \<sigma>) = vars \<sigma>"
      and read_region_reg_update[simp]:  "read_region r (\<sigma>\<lparr>vars := x\<rparr>) = read_region r \<sigma>"
      and separate_irreflexive[simp]:    "\<not> separate r r"
      and separate_symmetric[symmetric]: "r \<bowtie> r' = r' \<bowtie> r"
      and separate_or_aliasing:          "r \<bowtie> r' \<or> r \<simeq> r'"
      and aliasing_def:                  "r \<simeq> r' \<equiv> r = r'"
begin

(* Evaluation *)
abbreviation "bool2expr f e0 e1 \<equiv> if f e0 e1 then 1 else 0"

primrec eval_Op
  where 
    "eval_Op Plus = (+)"
  | "eval_Op Mult = (*)"
  | "eval_Op Eq   = bool2expr (=)"
  | "eval_Op Le   = bool2expr (\<le>)"
  | "eval_Op And  = bool2expr (\<lambda> e0 e1 . e0 \<noteq> 0 \<and> e1 \<noteq> 0)"

(* to evaluate an expression and a predicate, a valuation \<phi> is needed, i.e., an assignment of values to metavariables *)
fun eval_E :: "'M state \<Rightarrow> (\<mu>V \<Rightarrow> 64 word) \<Rightarrow> E \<Rightarrow> 64 word"
  where 
    "eval_E s \<phi> (Num n)          = n"
  | "eval_E s \<phi> (Var v)          = vars s v"
  | "eval_E s \<phi> (MetaVar v)      = \<phi> v"
  | "eval_E s \<phi> (Deref \<lbrakk>a,si\<rbrakk>)    = read_region (eval_E s \<phi> a,si) s"
  | "eval_E s \<phi> (SP_AL \<lbrakk>a0,s0\<rbrakk> \<lbrakk>a1,s1\<rbrakk> e0 e1) = 
      (if  (eval_E s \<phi> a0,s0) \<bowtie> (eval_E s \<phi> a1,s1) then eval_E s \<phi> e0 else eval_E s \<phi> e1)"
  | "eval_E s \<phi> (App e0 op e1)  =  eval_Op op (eval_E s \<phi> e0) (eval_E s \<phi> e1)"

primrec eval_E' :: "'M state \<Rightarrow> (\<mu>V \<Rightarrow> 64 word) \<Rightarrow> E' \<Rightarrow> 64 word set"
  where "eval_E' s \<phi> (DExpr e) = {eval_E s \<phi> e}"
  | "eval_E' s \<phi> (NDExpr \<mu>v e) = { i . eval_E s (\<phi>(\<mu>v := i)) e \<noteq> 0}"

fun eval_P 
  where 
    "eval_P s \<phi> (Expr e) m = (eval_E s \<phi> e = m)"
  | "eval_P s \<phi> (Exists \<mu>v e P) m = (\<exists> i . eval_E s (\<phi>(\<mu>v := i)) e \<noteq> 0 \<and> eval_P s (\<phi>(\<mu>v := i)) P m)"

(*
  A predicate holds if it holds for some initial valuation
*)
definition holds_P :: "'M state \<Rightarrow> P \<Rightarrow> bool"
  where "holds_P s P \<equiv> \<exists> \<phi> i . eval_P s \<phi> P i \<and> i \<noteq> 0"

abbreviation is_path :: "'s list \<Rightarrow> ('s \<Rightarrow> 's \<Rightarrow> bool) \<Rightarrow> bool"
  where "is_path \<pi> t \<equiv> \<pi> \<noteq> [] \<and> (\<forall> i < length \<pi> - 1 . t (\<pi>!i) (\<pi>!(i+1)))"

(* Semantics: the step function

  Loop B C:
    goes from state s to s' if there exists some path [s, ...s\<^sub>n, s'] where B possibly holds for all states other than s'
    n may be zero, i.e., it may be that s == s'
  While B C:
    goes from state s to s' if Loop B C goes from s to s' and B does not hold in state s'.

  The reason for the split between Loop and While is because it makes proving easier.
*)
inductive step :: "C \<Rightarrow> 'M state \<Rightarrow> 'M state \<Rightarrow> bool"
  where 
    "m \<in> eval_E' s \<phi> e' \<Longrightarrow> s' = s\<lparr>vars := (vars s)(v := m)\<rparr> \<Longrightarrow> step (v ::= e') s s'"
  | "eval_E s \<phi> a = m \<Longrightarrow> eval_E s \<phi> (Var v) = m' \<Longrightarrow> s' = write_region (m,si) m' s \<Longrightarrow> step (Store \<lbrakk>a,si\<rbrakk> v) s s'"
  | "step S0 s s' \<Longrightarrow> step S1 s' s'' \<Longrightarrow> step (S0;S1) s s''"
  | "is_path p (step C) \<Longrightarrow> hd p = s \<Longrightarrow>  last p = s' \<Longrightarrow> \<forall> s0 \<in> set (butlast p) . holds_P s0 (Expr B) \<Longrightarrow> step (Loop B C) s s'"
  | "step (Loop B C) s s' \<Longrightarrow> holds_P s' (Expr (\<not>\<^sub>s B)) \<Longrightarrow> step (While B C) s s'"
  | "step C0 s s' \<or> step C1 s s' \<Longrightarrow> step (C0 \<parallel> C1) s s'"

(*
   The definition of an exploit-triple:
    If P holds, then after execution of code C, postcondition Q may hold.
 *)
definition exploit_triple ("\<lbrace>_\<rbrace> _ \<lbrace>_\<rbrace>")
  where "\<lbrace>P\<rbrace> C \<lbrace>Q\<rbrace> \<equiv> \<forall> s . holds_P s P \<longrightarrow> (\<exists> s' . step C s s' \<and> holds_P s' Q)"



(*
  Substitution: replacing a variable with an expression, i.e:
  
    subst_E v e' e 

  is equal to:

    e[v := e']
*)
fun subst_E :: "V \<Rightarrow> E \<Rightarrow> E \<Rightarrow> E"
  where
    "subst_E v e' (Num n)                    = Num n"
  | "subst_E v e' (Var v')                   = (if v = v' then e' else Var v')"
  | "subst_E v e' (MetaVar v')               = MetaVar v'"
  | "subst_E v e' (Deref \<lbrakk>a,s\<rbrakk>)               = Deref \<lbrakk>subst_E v e' a,s\<rbrakk>"
  | "subst_E v e' (SP_AL \<lbrakk>a,s\<rbrakk> \<lbrakk>a',s'\<rbrakk> e0 e1) = SP_AL \<lbrakk>subst_E v e' a,s\<rbrakk> \<lbrakk>subst_E v e' a',s'\<rbrakk> (subst_E v e' e0) (subst_E v e' e1)"
  | "subst_E v e' (App e0 f e1)              = App (subst_E v e' e0) f (subst_E v e' e1)"

primrec subst_P :: "V \<Rightarrow> E \<Rightarrow> P \<Rightarrow> P"
  where "subst_P v e' (Expr e'') = Expr (subst_E v e' e'')"
  | "subst_P v e' (Exists v'' e'' P) = Exists v'' (subst_E v e' e'') (subst_P v e' P)"

(*
  Substitution: replacing a meta variable with another meta-variable:
  
    subst_\<mu>v \<mu>v \<mu>v' e 

  is equal to:

    e[\<mu>v := \<mu>v']
*)
fun subst_\<mu>v :: "\<mu>V \<Rightarrow> \<mu>V \<Rightarrow> E \<Rightarrow> E"
  where
    "subst_\<mu>v \<mu>v \<mu>v' (Num n)                    = Num n"
  | "subst_\<mu>v \<mu>v \<mu>v' (Var v)                    = Var v"
  | "subst_\<mu>v \<mu>v \<mu>v' (MetaVar \<mu>v'')             = (if \<mu>v'' = \<mu>v then MetaVar \<mu>v' else MetaVar \<mu>v'')"
  | "subst_\<mu>v \<mu>v \<mu>v' (Deref \<lbrakk>a,s\<rbrakk>)               = Deref \<lbrakk>subst_\<mu>v \<mu>v \<mu>v' a,s\<rbrakk>"
  | "subst_\<mu>v \<mu>v \<mu>v' (SP_AL \<lbrakk>a,s\<rbrakk> \<lbrakk>a',s'\<rbrakk> e0 e1) = SP_AL \<lbrakk>subst_\<mu>v \<mu>v \<mu>v' a,s\<rbrakk> \<lbrakk>subst_\<mu>v \<mu>v \<mu>v' a',s'\<rbrakk> (subst_\<mu>v \<mu>v \<mu>v' e0) (subst_\<mu>v \<mu>v \<mu>v' e1)"
  | "subst_\<mu>v \<mu>v \<mu>v' (App e0 f e1)              = App (subst_\<mu>v \<mu>v \<mu>v' e0) f (subst_\<mu>v \<mu>v \<mu>v' e1)"

(*
  The set of metavariables from the expression/predicate
*)
fun \<mu>vars :: "E \<Rightarrow> \<mu>V set"
  where
    "\<mu>vars (Num n) = {}"
  | "\<mu>vars (Var v) = {}"
  | "\<mu>vars (MetaVar v) = {v}"
  | "\<mu>vars (Deref \<lbrakk>a,s\<rbrakk>) = \<mu>vars a"
  | "\<mu>vars (SP_AL \<lbrakk>a,s\<rbrakk> \<lbrakk>a',s'\<rbrakk>  e0 e1) = \<mu>vars a \<union> \<mu>vars a' \<union> \<mu>vars e0 \<union> \<mu>vars e1"
  | "\<mu>vars (App e0 op e1) = \<mu>vars e0 \<union> \<mu>vars e1"

primrec \<mu>vars_P
  where "\<mu>vars_P (Expr e) = \<mu>vars e"
  | "\<mu>vars_P (Exists \<mu>v e P) = {\<mu>v} \<union> \<mu>vars e \<union> \<mu>vars_P P"

(*
  Conjunction of a predicate and an expression
*)
primrec and_P :: "P \<Rightarrow> E \<Rightarrow> P"  (infixr "\<and>\<^sub>P" 35)
  where
    "(Expr e \<and>\<^sub>P e0) = Expr (e \<and>\<^sub>s e0)"
  | "(Exists v e P \<and>\<^sub>P e0) = Exists v e (P \<and>\<^sub>P e0)"

(*
  Implication for predicates
*)

definition implies_P :: "[P,P] \<Rightarrow> bool"  (infixr "\<longrightarrow>\<^sub>P" 25)
  where "P \<longrightarrow>\<^sub>P Q \<equiv> \<forall> s . holds_P s P \<longrightarrow> holds_P s Q"


(* Predicate transformation *)


(* First, predicate transformation for dealing with writing to memory (store) *)
fun \<tau>_store_E   :: "C \<Rightarrow> E \<Rightarrow> E"
and \<tau>_store_R :: "C \<Rightarrow> R \<Rightarrow> E"
  where
    "\<tau>_store_E c (Deref \<lbrakk>a,s\<rbrakk>)               = \<tau>_store_R c \<lbrakk>a,s\<rbrakk> "
  | "\<tau>_store_E c (SP_AL \<lbrakk>a,s\<rbrakk> \<lbrakk>a',s'\<rbrakk> e0 e1)  = (SP_AL \<lbrakk>\<tau>_store_E c a,s\<rbrakk> \<lbrakk>\<tau>_store_E c a',s'\<rbrakk>) (\<tau>_store_E c e0) (\<tau>_store_E c e1)"
  | "\<tau>_store_E c (App e0 op e1)              = App (\<tau>_store_E c e0) op (\<tau>_store_E c e1)"
  | "\<tau>_store_E c (Num n)                     = Num n"
  | "\<tau>_store_E c (Var v)                     = Var v"
  | "\<tau>_store_E c (MetaVar v)                 = MetaVar v"
  | "\<tau>_store_R (Store \<lbrakk>a',s'\<rbrakk> v) \<lbrakk>a,s\<rbrakk>        = (let a_\<tau> = \<tau>_store_E (Store \<lbrakk>a',s'\<rbrakk> v) a in
                                                  SP_AL \<lbrakk>a_\<tau>,s\<rbrakk> \<lbrakk>a',s'\<rbrakk> (Deref \<lbrakk>a_\<tau>,s\<rbrakk>) (Var v))"

primrec \<tau>_store_P :: "C \<Rightarrow> P \<Rightarrow> P"
  where
    "\<tau>_store_P c (Expr e)       = Expr (\<tau>_store_E c e)"
  | "\<tau>_store_P c (Exists v e P) = Exists v (\<tau>_store_E c e) (\<tau>_store_P c P)"

(* The complete predicate transformation function *)
inductive \<tau> :: "C \<Rightarrow> P \<Rightarrow> P \<Rightarrow> bool"
  where
  \<tau>_assign_D:  "\<mu>vars e = {} \<Longrightarrow> P = subst_P v e Q \<Longrightarrow> \<tau> (v ::= DExpr e) P Q"
| \<tau>_assign_ND: "\<mu>v\<^sub>f \<notin> \<mu>vars_P Q \<Longrightarrow> \<mu>v\<^sub>f \<notin> \<mu>vars e \<Longrightarrow> P = Exists \<mu>v\<^sub>f (subst_\<mu>v \<mu>v \<mu>v\<^sub>f e) (subst_P v (MetaVar \<mu>v\<^sub>f) Q) \<Longrightarrow> \<tau> (v ::= NDExpr \<mu>v e) P Q"
| \<tau>_store:     "case r of \<lbrakk>a,si\<rbrakk> \<Rightarrow> \<mu>vars a = {} \<Longrightarrow> P = \<tau>_store_P (Store r v) Q \<Longrightarrow> \<tau> (Store r v) P Q"
| \<tau>_seq:       "\<tau> C1 Q R \<Longrightarrow> \<tau> C0 P Q \<Longrightarrow> \<tau> (C0;C1) P R"
| \<tau>_loop_0:    "P = Q \<Longrightarrow> \<tau> (Loop B C) P Q"
| \<tau>_loop:      "\<mu>vars B = {} \<Longrightarrow> \<tau> C P\<^sub>1 Q \<Longrightarrow> \<tau> (Loop B C) P (P\<^sub>1 \<and>\<^sub>P B) \<Longrightarrow> \<tau> (Loop B C) P Q"
| \<tau>_while:     "\<mu>vars B = {} \<Longrightarrow> \<tau> (Loop B C) P (Q \<and>\<^sub>P (\<not>\<^sub>s B)) \<Longrightarrow> \<tau> (While B C) P Q"
| \<tau>_choice:    "\<tau> C0 P Q \<or> \<tau> C1 P Q \<Longrightarrow> \<tau> (C0 \<parallel> C1) P Q"
| \<tau>_weaken:    "\<tau> C P' Q \<Longrightarrow>  P \<longrightarrow>\<^sub>P P' \<Longrightarrow> \<tau> C P Q"


(* the following rule can be derived *)
lemma \<tau>_while_0:
  shows "\<mu>vars B = {} \<Longrightarrow> P = (Q \<and>\<^sub>P (\<not>\<^sub>s B)) \<Longrightarrow> \<tau> (While B C) P Q"
  apply (rule \<tau>_while)
  apply simp
  apply (rule \<tau>_loop_0)
  by simp



(* We prove correctness of tau.
  First, substitution lemma's:
*)

(* For determinstic expressions *)
lemma eval_E_subst_E:
  shows "eval_E s \<phi> (subst_E v e e') = eval_E (s\<lparr>vars := (vars s)(v := eval_E s \<phi> e)\<rparr>) \<phi> e'"
  by (induct v e e' rule: subst_E.induct,auto)

lemma valuation_independent:
  shows "\<mu>vars e = {} \<Longrightarrow> eval_E s \<phi> e = eval_E s \<phi>' e"
  by (induct s \<phi> e rule: eval_E.induct ,auto)

lemma eval_P_subst_P:
assumes "\<mu>vars e = {}"
  shows "eval_P s \<phi> (subst_P v e c) i \<longleftrightarrow> eval_P (s\<lparr>vars := (vars s)(v := eval_E s \<phi> e)\<rparr>) \<phi> c i"
  using assms
  apply (induct "s\<lparr>vars := (vars s)(v := eval_E s \<phi> e)\<rparr>" \<phi> c i rule: eval_P.induct,auto simp add: eval_E_subst_E fun_upd_twist valuation_independent)
  by (metis (full_types) valuation_independent)+

lemma holds_P_subst_P:
assumes "\<mu>vars e = {}"
    and "holds_P s (subst_P v e Q)"
  shows "\<exists> \<phi> . holds_P (s\<lparr>vars := (vars s)(v := eval_E s \<phi> e)\<rparr>) Q"
  using assms  
  by (auto simp add: holds_P_def eval_P_subst_P)


(* For non-determinstic expressions *)
lemma eval_E_subst_E_\<mu>var:
  assumes "\<mu>v \<notin> \<mu>vars e"
  shows "eval_E s (\<phi>(\<mu>v := m)) (subst_E v (MetaVar \<mu>v) e) = eval_E (s\<lparr>vars := (vars s)(v := m)\<rparr>) \<phi> e"
  using assms
  by (induct v "MetaVar \<mu>v" e rule: subst_E.induct,auto)

lemma eval_P_subst_P_\<mu>var:
assumes "\<mu>v  \<notin> \<mu>vars_P c"
shows "eval_P s (\<phi>(\<mu>v := m)) (subst_P v (MetaVar \<mu>v) c) i \<longleftrightarrow> eval_P (s\<lparr>vars := (vars s)(v := m)\<rparr>) \<phi> c i"
  using assms
  by (induct "s\<lparr>vars := (vars s)(v := m)\<rparr>" \<phi> c i arbitrary: m rule: eval_P.induct,auto simp add: eval_E_subst_E_\<mu>var fun_upd_twist)

lemma holds_P_subst_P_\<mu>var:
assumes "\<mu>v \<notin> \<mu>vars_P Q"
    and "holds_P s (Exists \<mu>v e (subst_P v (MetaVar \<mu>v) Q))"
  shows "\<exists> \<phi> m . eval_E s (\<phi>(\<mu>v := m)) e \<noteq> 0 \<and> holds_P (s\<lparr>vars := (vars s)(v := m)\<rparr>) Q"
  using assms  
  by (auto simp add: holds_P_def eval_P_subst_P_\<mu>var)

lemma eval_E_subst_fresh_\<mu>var:
  assumes "\<mu>v\<^sub>f \<notin> \<mu>vars e"
  shows "eval_E s (\<phi>(\<mu>v\<^sub>f := m)) (subst_\<mu>v \<mu>v \<mu>v\<^sub>f e) = eval_E s (\<phi>(\<mu>v := m)) e"
  using assms
  by (induct s "(\<phi>(\<mu>v := m))" e rule: eval_E.induct ,auto)



(* we prove correctness of the transformation for a Store *)
lemma \<tau>_store_E_correct_store:
  assumes "c = Store \<lbrakk>a,si\<rbrakk> v"
      and "s' = write_region (eval_E s \<phi> a, si) (vars s v) s"
  shows "eval_E s' \<phi> e          = eval_E s \<phi> (\<tau>_store_E c e)"
    and "eval_E s' \<phi> (Deref r') = eval_E s \<phi> (\<tau>_store_R c r')"
  using assms
  apply (induct c e and c r' rule:  \<tau>_store_E_\<tau>_store_R.induct)
  apply (auto simp add: Let_def read_write_SP separate_symmetric)
  using aliasing_def read_write_AL separate_or_aliasing by metis

lemma \<tau>_store_P_correct_store:
  assumes "eval_P s \<phi> (\<tau>_store_P (Store \<lbrakk>a,si\<rbrakk> v) Q) i"
     and "\<mu>vars a = {}"
  shows "eval_P (write_region (eval_E s \<phi> a, si) (vars s v) s) \<phi> Q i"
  using assms
proof(induct Q arbitrary: \<phi>)
  case (Exists \<mu>v' e Q)
  thus ?case 
    using Exists valuation_independent
    apply auto
    by (metis \<tau>_store_E_correct_store(1))
next
  case (Expr x)
  then show ?case 
    apply auto
    using \<tau>_store_E_correct_store(1)
    by blast
qed


lemma not_in_butlast:
  shows "a \<in> set p \<Longrightarrow> a \<notin> set (butlast p) \<Longrightarrow> a = last p"
  by (induct p,auto)

lemma eval_P_conj1:
  shows "i \<noteq> 0 \<Longrightarrow> eval_P s \<phi> (P \<and>\<^sub>P B) i \<Longrightarrow> \<exists>i. i \<noteq> 0 \<and> eval_P s \<phi> P i"
  apply (induct s \<phi> P i rule: eval_P.induct)
  apply (auto simp add: split: if_split_asm)
  by blast

lemma holds_P_conj1:
  shows "holds_P s (P\<^sub>1 \<and>\<^sub>P B) \<Longrightarrow> holds_P s P\<^sub>1"
  apply (auto simp add: holds_P_def)
  using eval_P_conj1 by blast

lemma eval_P_conj2:
  shows "i \<noteq> 0 \<Longrightarrow> \<mu>vars B = {} \<Longrightarrow> eval_P s \<phi> (P \<and>\<^sub>P B) i \<Longrightarrow> \<exists>i. i \<noteq> 0 \<and> eval_E s \<phi> B = i"
  apply (induct s \<phi> P i rule: eval_P.induct)
  apply (auto simp add: split: if_split_asm)
  by (metis valuation_independent)

lemma holds_P_conj2:
  shows "holds_P s' (P\<^sub>1 \<and>\<^sub>P B) \<Longrightarrow> \<mu>vars B = {} \<Longrightarrow> holds_P s' (Expr B)"
  apply (auto simp add: holds_P_def )
  using eval_P_conj2 by blast

theorem \<tau>_correct:
assumes "\<tau> S P Q"
  shows "\<lbrace>P\<rbrace> S \<lbrace>Q\<rbrace>"
  using assms
proof(induct S P Q rule: \<tau>.induct)
  case (\<tau>_assign_D e P v Q)
  {
    fix s
    assume "holds_P s P"
    hence "holds_P s (subst_P v e Q)"
      using \<tau>_assign_D 
      by simp
    then obtain \<phi> where "holds_P (s\<lparr>vars := (vars s)(v := eval_E s \<phi> e)\<rparr>) Q"
      using holds_P_subst_P[of e s v Q] \<tau>_assign_D(1)
      by auto
    moreover
    hence "step (v ::= DExpr e) s (s\<lparr>vars := (vars s)(v := eval_E s \<phi> e)\<rparr>)"
      using step.intros(1)[of "eval_E s \<phi> e" s \<phi> "DExpr e" "s\<lparr>vars := (vars s)(v := eval_E s \<phi> e)\<rparr>" v]
      by auto
    ultimately
    have "\<exists> s' . step (v ::= DExpr e) s s' \<and> holds_P s' Q"
      by auto
  }
  thus ?case
    by (auto simp add: exploit_triple_def)
next 
  case (\<tau>_assign_ND \<mu>v\<^sub>f Q e P \<mu>v v)
  {
    fix s
    assume "holds_P s P"
    hence "holds_P s (Exists \<mu>v\<^sub>f (subst_\<mu>v \<mu>v \<mu>v\<^sub>f e) (subst_P v (MetaVar \<mu>v\<^sub>f) Q))"
      using \<tau>_assign_ND 
      by simp
    then obtain \<phi> m where "eval_E s (\<phi>(\<mu>v\<^sub>f := m)) (subst_\<mu>v \<mu>v \<mu>v\<^sub>f e) \<noteq> 0 \<and> holds_P (s\<lparr>vars := (vars s)(v := m)\<rparr>) Q"
      using holds_P_subst_P_\<mu>var[of \<mu>v\<^sub>f Q s "subst_\<mu>v \<mu>v \<mu>v\<^sub>f e" v] \<tau>_assign_ND(1)
      by auto
    hence "eval_E s (\<phi>(\<mu>v := m)) e \<noteq> 0 \<and> holds_P (s\<lparr>vars := (vars s)(v := m)\<rparr>) Q"
      using \<tau>_assign_ND 
      by (auto simp add: eval_E_subst_fresh_\<mu>var)
    moreover
    hence "step (v ::= NDExpr \<mu>v e) s (s\<lparr>vars := (vars s)(v := m)\<rparr>)"
      using step.intros(1)[of m s \<phi> "NDExpr \<mu>v e" "s\<lparr>vars := (vars s)(v := m)\<rparr>" v]
      by auto
    ultimately
    have "\<exists> s' . step (v ::= NDExpr \<mu>v e) s s' \<and> holds_P s' Q"
      by auto
  }
  thus ?case
    by (auto simp add: exploit_triple_def)
next 
  case (\<tau>_store r P v Q)
  {
    fix s
    assume "holds_P s P"
    hence P: "holds_P s (\<tau>_store_P (Store r v) Q)"
      using \<tau>_store 
      by simp
    obtain a si where r: "r = \<lbrakk>a,si\<rbrakk>"
      by (cases r,auto)
    obtain i \<phi> where i: "i \<noteq> 0 \<and> eval_P s \<phi> (\<tau>_store_P (Store r v) Q) i"
      using P
      by (auto simp add: holds_P_def)
    let ?s' = "write_region (eval_E s \<phi> a, si) (eval_E s \<phi> (Var v)) s"
    have "step (Store r v) s ?s'"
      using step.intros(2) r
      by auto
    moreover
    have "i \<noteq> 0 \<and> eval_P ?s' \<phi> Q i"
      using \<tau>_store_P_correct_store[of s \<phi> a si v Q i] P i r \<tau>_store
      by auto
    ultimately
    have "\<exists> s' . step (Store r v) s s' \<and> holds_P s' Q"
      by (auto simp add: holds_P_def)
  }
  thus ?case
    by (auto simp add: exploit_triple_def)
next
  case (\<tau>_seq C2 Q R C1 P)
  let ?S = "C1 ; C2"
  {
    fix s
    assume "holds_P s P"
    from this \<tau>_seq(4) obtain s' where "step C1 s s' \<and> holds_P s' Q"
      by (auto simp add: exploit_triple_def)
    moreover
    from this \<tau>_seq(2) obtain s'' where "step C2 s' s'' \<and> holds_P s'' R"
      by (auto simp add: exploit_triple_def)
    ultimately
    have "\<exists> s'' . step ?S s s'' \<and> holds_P s'' R"
      apply auto
      using step.intros(3)
      by blast
  }
  thus ?case
    by (auto simp add: exploit_triple_def)
next
  case (\<tau>_loop_0 P Q B C)
  {
    fix s
    assume 1: "holds_P s P"
    have "step (Loop B C) s s"
      apply (rule step.intros(4)[of "[s]"])
      using \<tau>_loop_0 1
      by (auto simp add: holds_P_def split: if_split_asm)
    moreover
    have "holds_P s Q"
      using \<tau>_loop_0 1
      by (auto simp add: holds_P_def)
    ultimately
    have "\<exists> s' . step (Loop B C) s s' \<and> holds_P s' Q"
      by auto
  }
  thus ?case
    by (auto simp add: exploit_triple_def)
next
  case (\<tau>_loop B C P\<^sub>1 Q P)
  {
    fix s
    assume 1: "holds_P s P"
    from this \<tau>_loop(5)
    obtain s' where 2: "step (Loop B C) s s' \<and> holds_P  s' (P\<^sub>1 \<and>\<^sub>P B)"
      by (auto simp add: exploit_triple_def)
    from this \<tau>_loop(3)
    obtain s'' where 3: "step C s' s'' \<and> holds_P s'' Q"      
      using holds_P_conj1[of s' P\<^sub>1 "B"]
      by (auto simp add: exploit_triple_def)
    obtain p where 4: "is_path p (step C) \<and> hd p = s \<and> last p = s' \<and> (\<forall>s\<in>set (butlast p) . holds_P s (Expr B))"
      using step.cases[of "Loop B C" s s' False] 2
      by auto
    let ?p' = "p @ [s'']"
    have "is_path ?p' (step C)"
      using 4
      apply (auto)
      by (metis "3" One_nat_def Suc_lessI add.commute add_diff_cancel_left' last_conv_nth less_diff_conv nth_append_length plus_1_eq_Suc nth_append)
    moreover
    have "hd ?p' = s"
      using 4
      by auto
    moreover
    have "last ?p' = s''"
      using 4
      by auto
    moreover
    have "\<forall>s\<in>set (butlast ?p'). holds_P s (Expr B)"
      using 2 3 4 not_in_butlast[of _ p] holds_P_conj2 \<tau>_loop(1)
      by auto
    ultimately
    have "step (Loop B C) s s''"
      by (rule step.intros(4))
    moreover
    have "holds_P s'' Q"
      using 3
      by (auto simp add: holds_P_def)
    ultimately
    have "\<exists> s' . step (Loop B C) s s' \<and> holds_P s' Q"
      by auto
  }
  thus ?case
    by (auto simp add: exploit_triple_def)
next
  case (\<tau>_while B C P Q)
  {
    fix s
    assume 1: "holds_P s P"
    from this \<tau>_while(3)
    obtain s' where 2: "step (Loop B C) s s' \<and> holds_P s' (Q \<and>\<^sub>P (\<not>\<^sub>s B))"
      by (auto simp add: exploit_triple_def)
    have "step (While B C) s s'"
      apply (rule step.intros(5))
      using 2 holds_P_conj2 \<tau>_while(1)
      by (auto simp add: split: if_split_asm)
    hence "\<exists> s' . step (While B C) s s' \<and> holds_P s' Q"
      using 2 holds_P_conj1
      by auto
  }
  thus ?case
    by (auto simp add: exploit_triple_def)
next
  case (\<tau>_choice C0 P Q C1)
  {
    fix s
    assume P: "holds_P s P"
    hence "\<exists> s' . step (C0 \<parallel> C1) s s' \<and> holds_P s' Q"
      using \<tau>_choice exploit_triple_def step.intros(6)
      by blast
  }
  thus ?case
    by (auto simp add: exploit_triple_def)
next
  case (\<tau>_weaken C P' Q P)
  {
    fix s
    assume "holds_P s P"
    hence "holds_P s P'"
      using \<tau>_weaken(3)
      by (auto simp add: implies_P_def)
    hence "\<exists> s' . step C s s' \<and> holds_P s' Q"
      using \<tau>_weaken(2)
      by (auto simp add: exploit_triple_def)
  }
  thus ?case
    by (auto simp add: exploit_triple_def)
next
qed




(*
   EXAMPLES
*)
abbreviation "x \<equiv> Var ''x''"
abbreviation "y \<equiv> Var ''y''"
abbreviation "z \<equiv> Var ''z''"

(*
  { y = z^2 \<and> z > 10 }
  While (z \<le> 10)
      x = y + z;
      y = z + x - 1;
      z = z + 1
  { y = z^2 }
*)
schematic_goal example_zero_iteration:
  assumes "C = While (z \<le>\<^sub>s Num 10)
                     (''x'' ::= DExpr (y +\<^sub>s z); 
                      ''y'' ::= DExpr (z +\<^sub>s x +\<^sub>s Num (-1));
                      ''z'' ::= DExpr (z +\<^sub>s Num 1))"
      and "Q = Expr (y ==\<^sub>s z *\<^sub>s z)"
    shows "\<tau> C ?P Q"
  apply (subst assms(1,2))+
  (* one iteration of the body *)
  apply (rule \<tau>_while_0)
  apply simp
  apply simp
  done

(*
  { 2z+y-1 = (z+1)^2 \<and> z=10 }
  While (z \<le> 10)
      x = y + z;
      y = z + x - 1;
      z = z + 1
  { y = z^2 }
*)
schematic_goal example_one_iteration:
  assumes "C = While (z \<le>\<^sub>s Num 10)
                     (''x'' ::= DExpr (y +\<^sub>s z); 
                      ''y'' ::= DExpr (z +\<^sub>s x +\<^sub>s Num (-1));
                      ''z'' ::= DExpr (z +\<^sub>s Num 1))"
      and "Q = Expr (y ==\<^sub>s z *\<^sub>s z)"
    shows "\<tau> C ?P Q"
  apply (subst assms(1,2))+
  apply (rule \<tau>_while)
  apply simp
  (* one iteration of the body *)
  apply (rule \<tau>_loop)
  apply simp
  apply (rule \<tau>_seq)
  apply (rule \<tau>_assign_D,simp,simp add: Let_def)
  apply (rule \<tau>_seq)
  apply (rule \<tau>_assign_D,simp,simp add: Let_def)
  apply (rule \<tau>_assign_D,simp,simp add: Let_def)
  apply (rule \<tau>_loop_0)
  apply simp
  done



schematic_goal example_Random:
  assumes "C = While (z \<le>\<^sub>s Num 3)
                  (''y'' ::= NDExpr 42 (MetaVar 42 \<le>\<^sub>s Num 2); 
                   ''x'' ::= DExpr (x +\<^sub>s y);
                   ''z'' ::= DExpr (z +\<^sub>s Num 1))"
      and "Q = Expr (x ==\<^sub>s Num 5)"
    shows "\<tau> C ?P Q"
  apply (subst assms(1,2))+
  apply (rule \<tau>_while)
  apply simp
  (* one iteration of the body *)
  apply (rule \<tau>_loop,simp)
  apply (rule \<tau>_seq)
  apply (rule \<tau>_assign_D,simp,simp add: subst_P_def)
  apply (rule \<tau>_seq)
  apply (rule \<tau>_assign_D,simp,simp add: subst_P_def)
  apply (rule \<tau>_assign_ND[of 43],simp,simp,simp add: subst_P_def)
  (* one iteration of the body *)
  apply (rule \<tau>_loop,simp)
  apply (rule \<tau>_seq)
  apply (rule \<tau>_assign_D,simp,simp add: subst_P_def)
  apply (rule \<tau>_seq)
  apply (rule \<tau>_assign_D,simp,simp add: subst_P_def)
  apply (rule \<tau>_assign_ND[of 44],simp,simp,simp add: subst_P_def)
  apply (rule \<tau>_loop_0)
  apply simp
  done









(*
(* simplification *)

(* some simple rewrite rules for expressions *)
fun simp_E :: "E \<Rightarrow> E"
  where 
    "simp_E (a +\<^sub>s (b +\<^sub>s c)) = a +\<^sub>s b +\<^sub>s c"
  | "simp_E (App e0 op e1) = App (simp_E e0) op (simp_E e1)"
  | "simp_E e = e"

(*
  A more advanced simplification:
  If e is a deterministic expression, then the predicate:
    Exists \<mu>v e c
  is equivalent to:
    c[\<mu>v := e]
  This simplification eliminates a quantifier.
*)
fun deterministic 
  where 
    "deterministic (Var v) = True"
  | "deterministic (Num n) = True"
  | "deterministic (MetaVar v) = False"
  | "deterministic (Deref \<lbrakk>a,s\<rbrakk>) = deterministic a"
  | "deterministic (SP_AL \<lbrakk>a,s\<rbrakk> \<lbrakk>a',s'\<rbrakk> e0 e1) = (deterministic a \<and> deterministic a' \<and> deterministic e0 \<and> deterministic e1)"
  | "deterministic (App e0 op e1) = (deterministic e0 \<and> deterministic e1)"
  | "deterministic (Fun f e) = False"

fun subst_E' :: "\<mu>V \<Rightarrow> E \<Rightarrow> E \<Rightarrow> E"
  where
    "subst_E' \<mu>v e (Num n)                    = Num n"
  | "subst_E' \<mu>v e (Var v')                   = Var v'"
  | "subst_E' \<mu>v e (MetaVar \<mu>v')              = (if \<mu>v = \<mu>v' then e else MetaVar \<mu>v')"
  | "subst_E' \<mu>v e (Deref \<lbrakk>a,s\<rbrakk>)              = Deref \<lbrakk>subst_E' \<mu>v e a,s\<rbrakk>"
  | "subst_E' \<mu>v e (SP_AL \<lbrakk>a,s\<rbrakk> \<lbrakk>a',s'\<rbrakk> e0 e1) = SP_AL \<lbrakk>subst_E' \<mu>v e  a,s\<rbrakk> \<lbrakk>subst_E' \<mu>v e  a',s'\<rbrakk> (subst_E' \<mu>v e e0) (subst_E' \<mu>v e e1)"
  | "subst_E' \<mu>v e (App e0 f e1)              = App (subst_E' \<mu>v e e0) f (subst_E' \<mu>v e e1)"
  | "subst_E' \<mu>v e (Fun f e')                 = Fun f (subst_E' \<mu>v e e')"

primrec subst_P'
  where "subst_P' \<mu>v e (Expr e') = Expr (subst_E' \<mu>v e e')"
  | "subst_P' \<mu>v e (Exists \<mu>v' e' c) = Exists \<mu>v' (subst_E' \<mu>v e e') (subst_P' \<mu>v e c)"

lemma size_subst_P':
  shows "size (subst_P' \<mu>v e c) < Suc (size c)"
  by (induct c,auto)

primrec quant_vars
  where "quant_vars (Expr e) = []"
  | "quant_vars (Exists \<mu>v e c) = \<mu>v# quant_vars c"

function simp_P
  where
    "simp_P (Expr e) = Expr (simp_E e)"
  | "simp_P (Exists \<mu>v e c) = (if \<mu>v \<notin> set (quant_vars c) \<and> deterministic e then simp_P (subst_P' \<mu>v e c) else Exists \<mu>v (simp_E e) (simp_P c))"
  by (pat_completeness,auto)
termination simp_P
  apply (relation "measure size")
  by (auto simp add: size_subst_P')

lemma simp_E_correct:
  shows "eval_E s \<phi> (simp_E e) m = eval_E s \<phi> e m"
  apply (induct e arbitrary: m rule: simp_E.induct,auto)
  apply fastforce+
  done
thm eval_E.induct


lemma deterministic_unique_value:
  shows "deterministic e \<Longrightarrow> \<exists>! m . eval_E s \<phi> e m"
  apply (induct e rule: \<mu>vars.induct,auto) 
  apply blast
  apply (meson separate_or_aliasing)
  apply (metis aliasing_def separate_irreflexive)
  apply (metis aliasing_def separate_irreflexive)
  by blast+

lemma deterministic_valuation_independent:
  assumes "deterministic e"
  shows "eval_E s \<phi>' e m \<longleftrightarrow> eval_E s \<phi> e m"
  using assms
  by (induct e arbitrary: m rule: \<mu>vars.induct, auto)

lemma temp1:
  assumes "deterministic e"
  shows "eval_E s \<phi> (subst_E' \<mu>v e e0) m \<longleftrightarrow> (\<exists>m'. eval_E s \<phi> e m' \<and> eval_E s (\<phi>(\<mu>v := m')) e0 m)"
  using assms 
  apply (induct e0 arbitrary: m rule: \<mu>vars.induct, auto simp add: every_term_evaluates_to_at_least_one_value)
  by (metis assms deterministic_unique_value)+

lemma eval_P_subst_P':
  assumes "\<mu>v \<notin> set (quant_vars c)"
      and "deterministic e"
  shows "eval_P s \<phi> (subst_P' \<mu>v e c) m \<longleftrightarrow> eval_P s \<phi> (Exists \<mu>v e c) m"
  using assms
  apply (induct s \<phi> c m arbitrary:  rule: eval_P.induct,auto simp add: temp1)
  apply (metis deterministic_unique_value fun_upd_twist deterministic_valuation_independent)
  by (metis fun_upd_twist deterministic_valuation_independent)

lemma eval_P_simp_P:
  shows "eval_P s \<phi> (simp_P P) = eval_P s \<phi> P"
  by (induct P arbitrary: \<phi> rule: simp_P.induct,auto simp add: simp_E_correct eval_P_subst_P')

lemma holdsP_simp_P:
  shows "holds_P s (simp_P P) = holds_P s P"
  by (auto simp add: holds_P_def eval_P_simp_P)
*)





(*
definition "fresh_\<mu>var c \<equiv> foldr max (\<mu>vars_P c) 0 + 1"

lemma foldr_max_is_max:
  fixes a :: int
  assumes "a \<in> set s"
  shows "foldr max s 0 \<ge> a"
  using assms
  by (induct s arbitrary: a,auto simp add: max.coboundedI2)

lemma fresh_\<mu>var_is_fresh:
  shows "fresh_\<mu>var c \<notin> set (\<mu>vars_P c)"
  using foldr_max_is_max[of "foldr max (\<mu>vars_P c) 0 + 1" "\<mu>vars_P c"] 
  by (auto simp add: fresh_\<mu>var_def)
*)
end